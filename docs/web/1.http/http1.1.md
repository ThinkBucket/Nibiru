---
id: http1.1
title: HTTP/1.1
sidebar_label: HTTP/1.1
---

import Img from '../../../src/components/Img';

## 长连接

一个 HTTP 的通信生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。为了解决这个问题，有些浏览器在请求时，用了一个非标准的 Connection 字段：Connection: keep-alive，但这个并不是标准字段。即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。

1.1 版的最大变化，就是引入了**持久连接（persistent connection）**，客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送 Connection: close，明确要求服务器关闭 TCP 连接。

目前，对于同一个域名，大多数浏览器允许同时建立 6 个持久连接。

没有数据传也要保持 tcp 连接就是长连接。反之就是短连接。

在 HTTP1.1 中进行了改进，有了一个 keep-alive，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response，也就是合并多个请求。但是一个 Request 只能对应一个 Response，而且这个 Response 是被动的，不能主动发起。

Keep-Alive 解决的核心问题：一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的一定时间是可以配置的，不管你用的是 Apache 还是 nginx。

长接连的特点：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

- 开启：http 1.1 中默认启用 Keep-Alive，目前大部分浏览器都是用 http1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求。
- 关闭：在 http 头中设置 Connection: close，即可关闭。
- 设置连接时间： 在 http header 中设置 Keep-Alive: timeout=5, max=1000， timeout 是超时时间，单位秒，超过这个时间后就断开连接， max 是最多的连接次数，若超过这个次数就强制断开连接。

Keep-Alive，他解决了多次连接的问题，但是依然有两个效率上的问题：

- 串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）

- 连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。

## 管道机制

HTTP/1.1 版还引入了管道机制（pipelining），即在同一个 TCP 连接里面，客户端可以同时发送多个请求。这样就进一步改进了 HTTP 协议的效率。

举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。_管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求_。

**由于浏览器供应商难以实现，现被禁用或删除**

<Img w="500" align="center" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/RUc1N2.png'/>
