---
id: insertion-sort
title: 插入排序
---

import Img from '../../../src/components/Img';

## 思想

插入排序会把待排序列划分为两个区间，已排序区间和未排序区间。初始已排序区间只有第一个元素。插入算法的核心思想是**取未排序区间中的元素，在已排序区间中找到合适的位置将其插入，并保证已排序区间数据一直有序**。重复这个过程，直到未排序区间中元素为空，算法结束。

如下图所示，待排序列是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200622002437.png'/>

排序的过程中设计到两种操作，一种是和已排序区间的元素比较，找插入位置，另一种是当找到插入位置后，插入位置之后的元素移动。

需要注意的是元素的移动次数是与逆序数相同的，如下图所示：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200622002815.png'/>

我们可以计算出初始序列的逆序数是和移动元素个数总和是完全相等的。

## 实现

```js
/* 插入排序思想：第一个元素有序，从第二个元素开始，在前面有序的元素中一次比较找到合适的插入位置*/
/*空间复杂度O(1),时间复杂度在完全有序时为O(n)，倒序时为最坏情况，时间复杂度O(n^2) */

function insertionSort(arr) {
  const length = arr.length;
  if (length <= 1) return arr;

  for (let i = 1; i < length; i++) {
    let value = arr[i];
    let j = i - 1;

    while (j >= 0 && arr[j] > value) {
      // 对已有序的元素遍历，如果值大于value就继续向前找，不大于的话就插入，插入排序是稳定排序
      arr[j + 1] = arr[j];
      j--;
    }

    if (j + 1 !== i) {
      // 如过arr[i]不用移动，那么就不需要插入操作
      arr[j + 1] = value;
    }
  }

  return arr;
}
```

## 分析

### 空间复杂度

通过上面的算法实现可以看出，该算法不需要额外的辅助空间，即空间复杂度为 n(1)。

### 时间复杂度

在完全有序时，不需要移动元素，只比较一次就可以找到插入位置，这也是最好的情况，时间复杂度为 O(n)。如果是倒序，每次插入都相当于在数组的第一个位置插入新的数据，需要移动所有的已排序数据，也是最坏的情况，时间复杂度为 O(n^2)。每次在已排序区间寻找插入位置的平均时间复杂度为 O(n)，所以循环 n 次插入的算法平均时间复杂度为 O(n^2)。

### 稳定性

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
