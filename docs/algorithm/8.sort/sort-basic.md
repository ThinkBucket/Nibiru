---
id: sort-basic
title: 排序基础
---

import Img from '../../../src/components/Img';

## overview

在之前学习排序算法的过程中，我们一般会将排序算法分为不同的种类来学习，比如插入类排序、选择类排序等等。但是在实际使用算法时，我们其实并不需要对算法属于哪一个种类关注太多，而更需要关注的是排序的时间复杂度、空间复杂度和排序的稳定性，从而根据业务场景选择适当的算法。本文也将以时间复杂度为纬度，来对常用的算法进行划分，对不同种类的算法进行比较。

## 有序度和满序度

对长度为 n 的待排序列进行排序时，n 个数据会有 n!种排列方式。不同的排列方式，排序需要的时间肯定是不一样的。为了更好的计算算法的时间复杂度，我们可以结合“有序度”和“逆序度”这两个概念来进行分析。

**有序度**是数组中具有有序关系的元素对的个数，有序元素对用数学表达式表示就是这样：

> 有序元素对：a[i] <= a[j], 如果 i < j。

<Img w="400" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200621210920.png'/>

当一个序列完全有序的时候，那么这个序列的有序度叫作**满有序度**。

**逆序度** = 满有序度 - 有序度。上图中的有序度为 11，对应的逆序度为 4。

我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

## O(n^2)

时间复杂度为 O(n^2)的排序算法为冒泡排序、直接插入排序和选择类排序。

### Bubble Sort

算法思想： 冒泡排序每次冒泡操作都会对相邻的两个元素进行比较，如果相邻元素左侧较大，则交换两个元素，一趟冒泡排序最大的元素会被放到最后。在这个过程中，大的元素会像石头一样沉入水底，而小的元素就像是气泡一样向上浮动，所以这个排序被形象的称为冒泡排序。

下面使用一个例子，来演示下冒泡排序的整个过程。首先设定一组待排序数据 4，5，6，3，2，1。并将其从小到大进行排序。第一次冒泡操作的详细过程如下图所示：

<Img w="400"  origin="https://time.geekbang.org/column/article/41802?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" legend="一趟冒泡操作" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200621170312.png'/>

通过上图可以看出，经过一趟冒泡操作，待排数据中最大的值被放到了正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。

<Img w="400" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200621171538.png'/>

#### 算法实现

根据前面的讲解，其实算法很容易实现。我们只需要两次循环就可以搞定，其中外层循环用于待表冒泡次数，内部循环用来比较相邻两个元素，并在符合条件的时候进行交换元素。**当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作**。

具体的实现如下所示：

```js
function bubble(arr) {
  const length = arr.length;
  if (length <= 1) return arr;

  for (let i = 0; i < length; i++) {
    let flag = false; // 设置标志位，当为false表示没有交换，此时应该返回数组
    for (let j = 0; j < length - i - 1; j++) {
      // 后面是和j+1个元素比较，所以还需要再减一
      if (arr[j] > arr[j + 1]) {
        // 保证冒泡是稳定的算法
        let tmp = arr[j]; // 需要额外的一个空间，空间复杂度为O(1)
        arr[j] = arr[j + 1];
        arr[j + 1] = tmp;
        flag = true;
      }
    }
    if (!flag) return arr;
  }

  return arr;
}
```

#### 算法分析

- 空间复杂度

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的辅助空间，所以它的空间复杂度为 O(1)。

- 稳定性

从算法实现中可以看出，交换只会出现在相邻两个元素中。为了保证冒泡排序算法的稳定性，当相邻的两个元素大小相等的时候，我们不做交换。那么相同大小的数据在排序前后的顺序就不会改变，所以冒泡排序是稳定的排序算法。

- 时间复杂度

冒泡排序最好的情况是在待排数据完全有序的时候，没有元素交换，此时只需要一趟冒泡就可以跳出循环，时间复杂度为 O(n)。最坏的情况为倒序，需要通过 n 次冒泡，时间复杂度为 O(n^2)。平均时间复杂度为 n(n^2)。

平均时间复杂度如果使用概率论来计算相对来说比较复杂，我们可以通过“有序度”和“逆序度”这两个概念来进行分析。

<Img w="400" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200621220102.png'/>

通过上图我们可看出待排序列 4，5，6，3，2，1 的有序元素对有 (4，5)(4，6)(5，6)，所以有序度是 3。我么可以看到通过 5 次冒泡，可以把有序度调整为 15，即为序列的满序度`n*(n-1)/2=15`。也就是排序的过程其实就是把逆序度转换为有序度的过程。所以无论我们如何该算法，交换次数总是确定的，即为逆序度 12。

有序序列的逆序度为 0，不需要交换。而序列逆序时，需要进行`n*(n-1)/2` 次交换。我们可以取个中间值`n*(n-1)/4`，来表示初始有序度既不是很高也不是很低的平均情况。也就是平均情况下，需要 `n*(n-1)/4` 次交换操作，而比较操作肯定要比交换操作多，所以平均时间复杂度也是 O(n)。

### Insertion Sort

算法思想：插入排序会把待排序列划分为两个区间，已排序区间和未排序区间。初始已排序区间只有第一个元素。插入算法的核心思想是**取未排序区间中的元素，在已排序区间中找到合适的位置将其插入，并保证已排序区间数据一直有序**。重复这个过程，直到未排序区间中元素为空，算法结束。

如下图所示，待排序列是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。

<Img w="400" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200622002437.png'/>

排序的过程中设计到两种操作，一种是和已排序区间的元素比较，找插入位置，另一种是当找到插入位置后，插入位置之后的元素移动。

需要注意的是元素的移动次数次数是与逆序度相同的，如下图所示：

<Img w="400" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200622002815.png'/>

我们可以计算出初始序列的逆序度是和移动元素个数总和是完全相等的。

#### 算法实现

```js
/* 插入排序思想：第一个元素有序，从第二个元素开始，在前面有序的元素中一次比较找到合适的插入位置*/
/*空间复杂度O(1),时间复杂度在完全有序时为O(n)，倒序时为最坏情况，时间复杂度O(n^2) */

function inserttionSort(arr) {
  const length = arr.length;
  if (length <= 1) return arr;

  for (let i = 1; i < length; i++) {
    let value = arr[i];
    let j = i - 1;

    while (j >= 0 && arr[j] > value) {
      // 对已有序的元素遍历，如果值大于value就继续向前找，不大于的话就插入，插入排序是稳定排序
      arr[j + 1] = arr[j];
      j--;
    }

    if (j + 1 !== i) {
      // 如过arr[i]不用移动，那么就不需要插入操作
      arr[j + 1] = value;
    }
  }

  return arr;
}
```

#### 算法分析

- 空间复杂度

通过上面的算法实现可以看出，该算法不需要额外的辅助空间，即空间复杂度为 n(1)。

- 稳定性

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

- 时间复杂度

在完全有序时，不需要移动元素，只比较一次就可以找到插入位置，这也是最好的情况，时间复杂度为 O(n)。如果是倒序，每次插入都相当于在数组的第一个位置插入新的数据，需要移动所有的已排序数据，也是最坏的情况，时间复杂度为 O(n^2)。每次在已排序区间寻找插入位置的平均时间复杂度为 O(n)，所以循环 n 次插入的算法平均时间复杂度为 O(n^2)。

### Selection Sort

算法思想：选择排序会将待排序列划分为已排序区间和未排序区间，**每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾**。选择排序的过程如下图所示：

<Img w="400" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200621225611.png'/>

#### 算法实现：

```js
function selectionSort(arr) {
  const length = arr.length;
  if (length <= 1) return arr;

  for (let i = 0; i < length; i++) {
    let minValue = arr[i];
    let index = i;
    for (let j = i + 1; j < length; j++) {
      if (arr[j] <= minValue) {
        // 遍历后面的元素，找出最小的元素
        minValue = arr[j];
        index = j;
      }
    }
    arr[index] = arr[i]; // 交换元素
    arr[i] = minValue;
  }

  return arr;
}
```

#### 算法分析

- 空间复杂度

通过上面的算法实现可以看出，该算法自己需要一个辅助空间存放 minValue，即空间复杂度为 n(1)。

- 稳定性

选择排序是不稳定的排序算法，比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。

- 时间复杂度

选择排序无论序列中的顺序如何，都会对未排序区域元素依次遍历，因此时间复杂度那种情况下都是 O(n^2)。

### O(n^2) 小结

<Img w="400" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200622001045.png'/>

通过对三种时间复杂度为 O(n^2)排序算法进行分析，我们不难看出，选择排序是这三种排序算法中最差的，排序即不稳定，而且时间复杂度始终为 O(n^2)。而冒泡排序和插入排序在空间复杂度、稳定性、时间复杂度上的数据是完全相同的，两种算法无论怎么优化，元素交换的次数也是一个固定值（逆序度）。但是我们我们可以通过两者的算法实现可以看出，在元素交换时，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。在数量级较大的情况下，插入排序的性能可能表现的更优。
