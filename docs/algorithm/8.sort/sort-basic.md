---
id: sort-basic
title: 排序基础
---

import Img from '../../../src/components/Img';

import Math from '../../../src/components/Math';

## overview

在之前学习排序算法的过程中，我们一般会将排序算法分为不同的种类来学习，比如插入类排序、选择类排序等等。但是在实际使用算法时，我们其实并不需要对算法属于哪一个种类关注太多，而更需要关注的是排序的时间复杂度、空间复杂度和排序的稳定性，从而根据业务场景选择适当的算法。本文也将以时间复杂度为纬度，来对常用的算法进行划分，对不同种类的算法进行比较。

## inversion

逆序数（inversion）： 在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个**逆序**。一个排列中**逆序的总数**就称为这个排列的**逆序数**。

当一个待排序列完全有序时，逆序数为 0，当完全逆序时，逆序数为`n * (n-1) / 2`。

## O(n^2)

时间复杂度为 O(n^2)的排序算法为冒泡排序、直接插入排序和选择类排序。

### Bubble Sort

算法思想： 冒泡排序每次冒泡操作都会对相邻的两个元素进行比较，如果相邻元素左侧较大，则交换两个元素，一趟冒泡排序最大的元素会被放到最后。在这个过程中，大的元素会像石头一样沉入水底，而小的元素就像是气泡一样向上浮动，所以这个排序被形象的称为冒泡排序。

下面使用一个例子，来演示下冒泡排序的整个过程。首先设定一组待排序数据 4，5，6，3，2，1。并将其从小到大进行排序。第一次冒泡操作的详细过程如下图所示：

<Img w="500"  origin="https://time.geekbang.org/column/article/41802?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" legend="一趟冒泡操作" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200621170312.png'/>

通过上图可以看出，经过一趟冒泡操作，待排数据中最大的值被放到了正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200621171538.png'/>

#### 算法实现

冒泡排序需要内外两层循环，其中外层循环用于代表冒泡次数，内层循环用来比较相邻两个元素，当左侧元素小于右侧元素时进行交换。**当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作**。

具体的实现如下所示：

```js
// 相邻两个元素交换
function swap(arr, a, b) {
  let tmp = arr[a];
  arr[a] = arr[b];
  arr[b] = tmp;
}

function bubble(arr) {
  const length = arr.length;
  if (length <= 1) return arr;

  for (let i = 0; i < length; i++) {
    let flag = false; // 设置标志位，当为false表示没有交换，此时应该返回数组
    for (let j = 0; j < length - i - 1; j++) {
      // 后面是和j+1个元素比较，所以还需要再减一
      if (arr[j] > arr[j + 1]) {
        // 保证冒泡是稳定的算法
        swap(arr, j, j + 1);
        flag = true;
      }
    }
    if (!flag) return arr;
  }

  return arr;
}
```

#### 算法分析

- 空间复杂度

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的辅助空间，所以它的空间复杂度为 O(1)。

- 稳定性

从算法实现中可以看出，交换只会出现在相邻两个元素中。为了保证冒泡排序算法的稳定性，当相邻的两个元素大小相等的时候，我们不做交换。那么相同大小的数据在排序前后的顺序就不会改变，所以冒泡排序是稳定的排序算法。

- 时间复杂度

冒泡排序最好的情况是在待排数据完全有序的时候，没有元素交换，此时只需要一趟冒泡就可以跳出循环，时间复杂度为 O(n)。最坏的情况为倒序，需要`n-1`趟冒泡，每趟排序要进行`n-i`次比较，所以时间复杂度为 O(n^2)。平均时间复杂度为 n(n^2)。

平均时间复杂度如果使用概率论来计算相对来说比较复杂，我们可以通过逆序数的概念来进行分析。在冒泡排序中会比较相邻两个元素，每次交换元素，序列的逆序数就会减 1。所以冒泡排序的过程就是一种减少逆序数的过程，当逆序数减少到 0 时，序列完全有序。

前面提到，完全有序的序列的逆序数为 0，排序时不需要交换。而序列逆序的逆序数为 `n*(n-1)/2`，则需要调用`n*(n-1)/2` 次 swap 方法。一个序列的逆序数的平均数为`n*(n-1)/4`，我们取平均交换的次数约为`n*(n-1)/4`，来表示初始逆序数的平均情况，则需要 `n*(n-1)/4` 次交换操作，而比较操作肯定要比交换操作多（比较了不一定交换，平均比较次数要大于`n*(n-1)/4`），所以平均时间复杂度也是 O(n^2)。

### Insertion Sort

算法思想：插入排序会把待排序列划分为两个区间，已排序区间和未排序区间。初始已排序区间只有第一个元素。插入算法的核心思想是**取未排序区间中的元素，在已排序区间中找到合适的位置将其插入，并保证已排序区间数据一直有序**。重复这个过程，直到未排序区间中元素为空，算法结束。

如下图所示，待排序列是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200622002437.png'/>

排序的过程中设计到两种操作，一种是和已排序区间的元素比较，找插入位置，另一种是当找到插入位置后，插入位置之后的元素移动。

需要注意的是元素的移动次数是与逆序数相同的，如下图所示：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200622002815.png'/>

我们可以计算出初始序列的逆序数是和移动元素个数总和是完全相等的。

#### 算法实现

```js
/* 插入排序思想：第一个元素有序，从第二个元素开始，在前面有序的元素中一次比较找到合适的插入位置*/
/*空间复杂度O(1),时间复杂度在完全有序时为O(n)，倒序时为最坏情况，时间复杂度O(n^2) */

function inserttionSort(arr) {
  const length = arr.length;
  if (length <= 1) return arr;

  for (let i = 1; i < length; i++) {
    let value = arr[i];
    let j = i - 1;

    while (j >= 0 && arr[j] > value) {
      // 对已有序的元素遍历，如果值大于value就继续向前找，不大于的话就插入，插入排序是稳定排序
      arr[j + 1] = arr[j];
      j--;
    }

    if (j + 1 !== i) {
      // 如过arr[i]不用移动，那么就不需要插入操作
      arr[j + 1] = value;
    }
  }

  return arr;
}
```

#### 算法分析

- 空间复杂度

通过上面的算法实现可以看出，该算法不需要额外的辅助空间，即空间复杂度为 n(1)。

- 稳定性

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

- 时间复杂度

在完全有序时，不需要移动元素，只比较一次就可以找到插入位置，这也是最好的情况，时间复杂度为 O(n)。如果是倒序，每次插入都相当于在数组的第一个位置插入新的数据，需要移动所有的已排序数据，也是最坏的情况，时间复杂度为 O(n^2)。每次在已排序区间寻找插入位置的平均时间复杂度为 O(n)，所以循环 n 次插入的算法平均时间复杂度为 O(n^2)。

### Selection Sort

算法思想：选择排序会将待排序列划分为已排序区间和未排序区间，**每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾**。选择排序的过程如下图所示：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200621225611.png'/>

#### 算法实现：

```js
function selectionSort(arr) {
  const length = arr.length;
  if (length <= 1) return arr;

  for (let i = 0; i < length; i++) {
    let minValue = arr[i];
    let index = i;
    for (let j = i + 1; j < length; j++) {
      if (arr[j] <= minValue) {
        // 遍历后面的元素，找出最小的元素
        minValue = arr[j];
        index = j;
      }
    }
    arr[index] = arr[i]; // 交换元素
    arr[i] = minValue;
  }

  return arr;
}
```

#### 算法分析

- 空间复杂度

通过上面的算法实现可以看出，该算法自己需要一个辅助空间存放 minValue，即空间复杂度为 n(1)。

- 稳定性

选择排序是不稳定的排序算法，比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。

- 时间复杂度

选择排序无论序列中的顺序如何，都会对未排序区域元素依次遍历，因此时间复杂度那种情况下都是 O(n^2)。

### O(n^2) 小结

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200622001045.png'/>

通过对三种时间复杂度为 O(n^2)排序算法进行分析，我们不难看出：

- 选择排序是这三种排序算法中最差的，排序即不稳定，而且时间复杂度始终为 O(n^2)。
- 冒泡排序和插入排序在空间复杂度、稳定性、时间复杂度上的数据是完全相同的，两种算法无论怎么优化，元素交换的次数也是一个固定值（逆序数）。
- 冒泡排序和插入排序在元素交换时，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。在数量级较大的情况下，插入排序的性能可能表现的更优。

## O(nlogn)

冒泡、插入和选择排序这三种算法的时间复杂度都是 O(n^2)，适合小规模数据的排序，当数据量较大时便不太实用。本节将介绍两种时间复杂度为 O(nlogn)的三种算法：快速排序、归并排序和堆排序。

### Quick Sort

算法思想：快速排序利用的是分治思想，在代排序列中挑选任意一个数据作为 pivot（分区点），将小于 pivot 的数据放到它的左边，将大于 pivot 的数据放到它的右边。然后再利用同样的方法分别对左边和右边的数据进行递归操作，直到区间缩小为 1，就说明所有的数据都有序了。

#### 快排分区

快速排序算法实现的关键是分区，关于分区我们一般会使用以下两种方案：

**方法一**： 申请两个临时的空数组 X、Y，每次取代排数组中间值为 pivot，小于 pivot 的放到 X 数组，大于中 pivot 的放 Y 数组。

为了更好的理解，我们可以假设代排序列为 8、10、2、5、6、1、3，分区操作如下图所示：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200626223158.jpg'/>

这种分区方式在实现起来也很方便，但是分区需要很多额外的内存空间，所以**分区操作**的空间复杂度就不是为 O(1)的原地排序算法了。

**方法二**： 使用双指针法，左右各一个指针，取第一个值 pivot，先移动右指针，大于等于 pivot 的时候像左移动，小于的时候停止。然后再移动左指针，在遇到不小于 pivot 的时候停止，交换两个指针所指向的元素，直到两指针指向同一个元素或左指针大于右指针为止。

使用双指针法进行分区，虽然操作起来更加的复杂，但是可以保证**分区操作**的空间复杂度为 O(1)。

#### 算法实现

采用方法一进行分区的算法如下所示：

```js
function quickSort(arr) {
  if (arr.length <= 1) {
    // 当分区只有一个元素的时候直接返回/终止递归
    return arr;
  }

  let left = [],
    right = []; // 设置两个临时数组
  const middleIndex = (arr.length / 2) >> 1; // 设置中间的元素为pivot
  const middle = arr[middleIndex];

  // 对元素分区
  for (let i = 0; i < arr.length; i++) {
    if (i !== middleIndex) {
      // 当元素不是pivot的时候才为其分区
      if (arr[i] >= middle) {
        right.push(arr[i]);
      } else {
        left.push(arr[i]);
      }
    }
  }
  // 递归左右分区，并将三个部分拼接在一起
  return quickSort(left).concat(middle, quickSort(right));
}
```

:::bad

从上面可以看出，算法的实现相当的简单，但是当递归没有回溯前，创建的数组也没有被释放，当数据量较大时，这是一个非常占用内存的写法，所以我们并不推荐这么写，包括面试的时候如果快排这么写的话，肯定是要减分的。

:::

采用双指针法进行分区的算法如下所示：

```js
function quickSort(arr, left, right) {
  if (i >= j) return; // 递归终止条件
  const pivot = arr[left]; // 设置第一个元素为pivot
  let i = left,
    j = right; // 设置左右指针

  while (i < j) {
    while (arr[j] >= pivot && i < j) {
      // 遇到小于pivot的时候停止
      j--;
    }
    while (arr[i] <= pivot && i < j) {
      // 遇到大于pivot的时候停止
      i++;
    }
    [arr[i], arr[j]] = [arr[j], arr[i]]; // 交换两个元素
  }
  [arr[i], arr[left]] = [arr[left], arr[i]]; // 交换pivot和i指针所指向的元素

  // 递归分区
  quickSort(arr, left, i - 1);
  quickSort(arr, i + 1, right);
}

quickSort(arr, 0, arr.length - 1);
```

#### 算法分析（双指针法）

- 空间复杂度

通过上面的算法实现可以看出，双指针法分区操作的空间复杂度为 O(1)，因为快排是使用递归操作的，递归深度为 O(logn)，所以该算法空间复杂度为 O(logn)。

- 稳定性

快排不是一个稳定的算法，例如这组数据 4，8，7，2，3，5，9，2，在经过第一次分区操作之后，两个 2 的相对先后顺序就会改变。

- 时间复杂度

使用双指针法进行一次分区操作的时间复杂度为 O(n)，使用快排最好情况为当每次分区都可以均等划分时，算法运行时间递归式为 `T(n) = 2T(n/2) + O(n)`。

```
T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......
```

当 n/2^k 的值为 1 的时候，<Math code="k = log_{2}n" />，此时时间复杂度为 O(nlog(n))。

使用快排最坏的情况为当每次分区被划分为 n-1 和 0 个元素时，此时时间复杂度的算法为 `T(n) = T(n-1) + T(0) + O(n)`，此时时间复杂度退化为 O(n^2)。

#### 快排优化

快速排序为了让分区变得更加的均匀，常见的优化方案有**三数取中法**和**随机法**。

1. 三数取中法：我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。

**算法实现:**

```js
function getMid(arr, left, mid, right) {
  if (arr[left] >= arr[mid]) {
    if (arr[mid] >= arr[right]) {
      return mid;
    } else if (arr[left] >= arr[right]) {
      return right;
    }
    return left;
  }
  // arr[left] < arr[mid]
  if (arr[right] >= arr[mid]) {
    return mid;
  } else if (arr[left] >= arr[right]) {
    return left;
  }
  return right;
}

function quickSort(arr, left, right) {
  if (i >= j) return; // 递归终止条件
  let mid = left + ((right - left) >> 1);
  mid = getMid(arr, left, mid, right); // 获取中间数
  if (mid != left) {
    // 中间大小的数如果不是最左边的元素时，交换
    [arr[mid], arr[left]] = [arr[left], arr[mid]];
  }
  const pivot = arr[left]; // 设置第一个元素为pivot
  let i = left,
    j = right; // 设置左右指针

  while (i < j) {
    while (arr[j] >= pivot && i < j) {
      // 遇到小于pivot的时候停止
      j--;
    }
    while (arr[i] <= pivot && i < j) {
      // 遇到大于pivot的时候停止
      i++;
    }
    [arr[i], arr[j]] = [arr[j], arr[i]]; // 交换两个元素
  }
  [arr[i], arr[left]] = [arr[left], arr[i]]; // 交换pivot和i指针所指向的元素

  // 递归分区
  quickSort(arr, left, i - 1);
  quickSort(arr, i + 1, right);
}

quickSort(arr, 0, arr.length - 1);
```

2. 随机法：随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n^2) 的情况，出现的可能性不大。

**算法实现:**

```js
function randQuickSort(arr, left, right) {
  if (i >= j) return; // 递归终止条件
  const pindex = ~~(Math.random() * (right - left)) + left;
  if (pindex != left) {
    // 随机取到的数如果不是最左边的元素时，交换
    [arr[pindex], arr[left]] = [arr[left], arr[pindex]];
  }
  const pivot = arr[left]; // 设置第一个元素为pivot
  //...
}
```

### Merge Sort

算法思想：将待排数组逐步二分，当二分长度为 1 的时候停止。然后再将分好的数组排序，并逐步合并为一个有序的数组。

归并排序分为两个阶段：分解和合并，在分解中利用分治思想，将数据递归拆分，然后再使用合并函数将分解后的数据有序的整合在一起。

归并过程如下图所示：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200627125544.png'/>

#### 算法实现：

```js
function mergeSort(arr) {
  const length = arr.length;
  if (length <= 1) {
    // 当数组为一个元素时停止
    return arr;
  }
  const mid = length >> 1;
  const left = arr.slice(0, mid);
  const right = arr.slice(mid, length);

  return merge(mergeSort(left), mergeSort(right)); //对原始数组递归二分
}

function merge(left, right) {
  const result = [];
  let i = 0;
  let j = 0;

  while (i < left.length && j < right.length) {
    //对二分好的数据排序整合在一起
    if (left[i] <= right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }
  // 处理剩余元素
  while (i < left.right) {
    result.push(left[j]);
    i++;
  }
  while (j < right.length) {
    result.push(right[j]);
    j++;
  }
  return result;
}
```

#### 性能分析

- 空间复杂度

由上面的算法可以看出，merge 函数中使用了一个临时数组 result，空间复杂度为 O(n)，但是 result 数组在每次合并后都会被释放，在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。

- 稳定性

归并排序的稳定性取决于 merge 函数，当我们在比较`left[i] <= right[j]`的时候，如果遇到相同的元素，让左边区间的元素先进 result，这样可以保证归并排序是个稳定的排序算法。

- 时间复杂度

归并排序 merge 操作的时间复杂度为 O(n)，在快排我们也讲过递归操作的递归深度为 logn，因此归并排序的时间复杂度为 O(nlogn)。归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。

虽然归并排序可以做到无论是什么情况时间复杂度都是 O(nlogn)，但是由于它的空间复杂度较高，当数据量较大的时候，内存占用量过大，因此归并排序只有在数据量较小，比如说 1k，2k 的时候可能会使用到，当数据量较大时还是会使用快速排序。

### Heap Sort

堆是一个完全二叉树，堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作**“大顶堆”**。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作**“小顶堆”**。

堆排序的关键就是将代排序列调整为堆。堆排序的过程可以分为**建堆和排序**两个步骤。

:::tip

在本节中为了更好的计算，让数据在数组中的存储的下标从 1 开始，这样可以保证数组中下标为 i 的节点的左子节点，就是下标为 `i*2` 的节点，右子节点就是下标为 `i*2+1` 的节点，父节点就是下标为 ​ `i/2` 的节点。

:::

#### 建堆

建堆思路：将序列调整为一个大顶堆，首先从后往前处理数组，找到第一个非叶子节点，然后比较其子节点，如果子节点的值大于当前节点，就将当前节点和最大的子节点交换。然后重复此过程，直到根节点调整完毕后结束。

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200627213004.png'/>

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200627213016.png'/>

由完全二叉树的特点不难得出，从 1 到 n/2 的元素都是非叶子节点，n/2+1 到 n 都是叶子节点。（其中 n/2 向下取整）

通过上面的描述，建堆的算法实现如下所示：

```js
// 元素交换
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}
// 遍历非叶子节点
function buildHeap(arr, n) {
  for (let i = n >> 1; i >= 1; --i) {
    heapify(arr, n, i); // a为数组 n为数组的长度 i为非叶子节点下标
  }
}

function heapify(arr, n, i) {
  while (true) {
    let maxPos = i;
    if (i * 2 <= n && arr[i] < arr[i * 2]) {
      // 与其做节点比较
      maxPos = i * 2;
    }
    if (i * 2 + 1 <= n && arr[maxPos] < arr[i * 2 + 1]) {
      // 用当前节点或左节点和右节点比较
      maxPos = i * 2 + 1;
    }
    if (maxPos === i) break;
    swap(arr, i, maxPos);
    i = maxPos;
  }
}
```

#### 排序

经过上面建堆的过程，我们会获得一个**大顶堆**，大顶堆的根元素是所有元素最大的，我们可以将其与最后一个元素交换，然后对剩下的`n-1`个元素进行排序。最后一个元素成为根元素后和其左右子元素比较，与较大的交换，然后再将根元素与最后一个元素交换，依次类推，直到剩余一个元素。排序的过程下图所示：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200703234649.png'/>

通过建堆的算法实现和排序的过程，得出的堆排序算法如下：

```js
// 元素交换
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}

// 遍历非叶子节点，建堆
function buildHeap(arr, n) {
  for (let i = n >> 1; i >= 1; --i) {
    heapify(arr, n, i); // a为数组 n为数组的长度 i为非叶子节点下标
  }
}

// 父子元素比较大小
function heapify(arr, n, i) {
  while (true) {
    let maxPos = i;
    if (i * 2 <= n && arr[i] < arr[i * 2]) {
      // 与其做节点比较
      maxPos = i * 2;
    }
    if (i * 2 + 1 <= n && arr[maxPos] < arr[i * 2 + 1]) {
      // 用当前节点或左节点和右节点比较
      maxPos = i * 2 + 1;
    }
    if (maxPos === i) break;
    swap(arr, i, maxPos);
    i = maxPos;
  }
}

// 排序
function heapSort(arr, length) {
  buildHeap(arr, length); // 建堆
  for (let n = length; n > 1; n--) {
    swap(arr, 1, n); // 交换根元素和最后一个元素
    heapify(arr, n, 1);
  }
}

arr.unshift(0); // 首部添加一个元素0
heapSort(arr, arr.length);
arr.shift(); // 删除第一个元素
```

#### 性能分析

- 空间复杂度

堆排序的过程，只需要个数级的辅助空间，因此堆排序是空间复杂度为**O(1)**的原地排序算法。

- 稳定性

堆排序是不稳定的排序算法，因为在排序的过程中会选择最后一个元素和根元素交换，一旦交换后堆稳定，不需要再交换，此时如果子树中有和根元素相同的元素，则改变了初始顺序，例如：9、5、4、5 中最后的一个 5 和 9 交换后堆稳定，最后的一个 5 输出，显然不稳定。

- 时间复杂度

由上面的代码不难看出，`堆排序的时间复杂度 = 建堆时间复杂度 + 排序时间复杂度`。

**建堆的时间复杂度**：建堆的主要工作是**遍历非叶子节点**和**调换父子节点**，这一过程也被称为堆化。也就是说堆化最多从树的倒数第二层到根元素都是需要的，而每个节点堆化的过程中，需要比较和交换的节点个数和这个节点的高度 k 成正比，如下图：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200704005328.png'/>

由上图可以看出高度为 1（倒数第二层）的非叶子节点为 2^(h-1)个，每个节点执行 heapify 函数中的 while 只需要执行 1 遍，而高度为 2 的非叶子节点，每个节点执行 heapify 函数 while 需要执行 2 遍，依次类推，我们发现将每个节点的高度求和，得出的就是建堆的时间复杂度。

求和公式为：

<Math code="S1 = 1*h + 2*(h-1) + 2^{2}*(h-2) + ... + 2^{h-1}*1" block />

计算该公式可以使用错位相减法：

<Math code="S2 = 2*h + 2^{2}*(h-1) + 2^{2}*(h-2) + ... + 2^{h-1}*2 + 2^{h}*1" block />

让<Math code="S2" />右错一位，然后减去<Math code="S1" />得到一个等比数列如下：

<Math code="S = S2 - S1 = -h + 2+ 2^{2} + 2^{2} + ... + 2^{h-1} + 2^{h}" block />

然后等比数列求和得出：

<Math code="S = 2^{h+1} - h - 2" block />

h 为树的高度 <Math code="log_{2}n" /> ，将 h 代进去，得出建堆的时间复杂度为 O(n)。

**排序时间复杂度：** 由算法可以看出排序时间复杂度为 for 循环时间 \* 并为每个节点进行堆化的时间，堆化的时间复杂度为 O(logn)，因此排序的时间复杂度为 O(nlogn)。

堆排序的时间复杂度 = 建堆时间复杂度 + 排序时间复杂度 = O(n) + O(nlogn)，因此堆排序得时间复杂度为 O(nlogn)。并且时间复杂度和初始序列顺序无关，时间复杂度始终为 O(nlogn)。

#### 堆排序的缺点

虽然堆排序的时间复杂度始终是 O(nlogn)，并且空间复杂度为 O(1)，而快速排序确只有最好的情况时间复杂度为 O(nlogn)，并且空间复杂度为 O(logn)，但是在实际开发中，快速排序却比堆排序性能表现的更好。

首先，堆排序在堆化的过程中，数据访问的方式一般是跳着访问，而不是像快速排序那样，局部顺序访问，所以，这样加重 CPU 缓存的负担。

其次，相比于快速排序，堆排序算法的数据交换次数要更多。快速排序元素的交换次数为初始序列的逆序数，而堆排序在建堆的时候会破坏初始序列的逆序数。例如当一个有序的初始序列，通过建大顶堆使得数据变得无序，如下图：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200704114522.png'/>

### O(nlogn)小结

时间复杂度为 O(nlogn)的排序有快速排序、归并排序和堆排序三种，它们的空间复杂度和稳定性如图所示：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200704111443.png'/>

在归并排序的性能分析中可以了解到，归并排序虽然稳定，但是空间复杂度高，在处理较小的排序序列可以使用，体积较大则不推荐使用。

当处理体积较大的排序时，由于堆排序交换存在一些缺点，我们可以选择快速排序。在使用快速排序时，可以使用"三数取中法"等方法对快速排序进行优化，使快速排序分区更均匀。

## O(n)

本节简单介绍两种排序算法：桶排序和基数排序，因为这两种算法是基于非比较的排序算法，不涉及元素之间的比较操作，所以这两种算法都可以将排序的时间复杂度降到 O(n)。时间复杂度 O(n)的排序算法也叫作线性排序（Linear sort）。

线性排序虽然时间复杂度和空间复杂度都相对较低，但是对初始序列要求非常苛刻，只能适用于极少数的应用场景。

### Bucket sort

核心思想：将待排序列分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。桶排序的关键是桶的划分，只要划分的合理，就可以接近线性时间复杂度。

为了更好的理解桶排序，可以结合下图理解排序过程：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200704230925.png'/>

#### 时间复杂度

将 n 个待排数据划分到 m 个桶内，每个桶有 **k=n/m** 个元素。对每个桶内元素进行快速排序，时间复杂度为 **O(k \* logk)**。m 个桶排序的时间复杂度就是 **O(m \* k \* logk)**，因为 **k = n/m**，所以桶排序的时间复杂度就是** O(n \* log(n/m))**。当桶的个数 m 接近数据个数 n 时，**log(n/m)** 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

#### 桶排序的适用场景

桶排序比较适合的场景：数据存储在外部磁盘中，并且数据量比较大，内存有限，无法将数据全部加载到内存中。

例如，当想对 10GB 的订单数据做排序时，显然内存是处理不了的，此时我们可以采用桶排序以订单的价格来划分桶。假设订单的价格区间为 1 元到 10 万元，此时可以将金额划分到 100 个桶里，第一个桶为 1 到 1000 元，第二个桶为 1001 到 2000，...，依次类推。然后在再对每个桶的这些数据进行快速排序，再依次合并数据。

如果价格分布均匀的话，我们期望每个桶的数据量都是 100MB，一旦数据分布不均，我们需要对数据量较大的再进行划分，比如，订单金额在 1 元到 1000 元之间的比较多，我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，...，901 元到 1000 元。如果仍然还有不均匀，无法一次性读入内存，可以对其再化分。

### Radix sort

算法思想：基数排序（Radix sort）要求待排序列可以分割出独立的**位**来比较，而且位之间有递进的关系，如果 a 数据的**高位**比 b 数据大，那剩下的**低位**就不用比较了。除此之外，**每一位的数据范围不能太大**，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法达到 O(n) 。

可能看完基数排序的算法思想不好理解，我们可以结合一个例子来理解。例如要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用再比较了，并且手机号都是 0-9 的数字，因此比较适合基数排序。

为了更好的理解排序的过程，我们可以简化一下场景为字符串长度为 3 的比较进行排序，排序过程如下图所示：

<Img w="500" src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200704233935.png'/>

:::tip

在按照位来排序时，要求排序算法必须是稳定的。假设如果排序算法不稳定，可能存在前面位相同，但是因为算法不稳定而交换了位置，然后后面位出现不同时，之前交换位置的数据，现在又重新交换了回来。

:::

当待排序列位数长短不同时，可以采用末尾补齐的办法，例如对字典中所有的英文字典排序，就可以通过再末尾补 0 的办法，让所有数据的位数都和最长的单词相同，此时便可以通过基数排序来排序了。

#### 时间复杂度

当每一位进行比较的时候，可以采用线性的桶排序，时间复杂度 O(n)，位数为 K，所以时间复杂度为 O(k\*n)，因为位数 k 较小，所以基数排序的时间复杂度可以做到 O(n)。

### O(n)小结

桶排序主要适用的是范围不大的数据，可以将数据划分成不同的桶，然后对每个桶进行快速排序，最终合并到一起完成排序。

基数排序要求数据可以按位划分，每一位的数据范围较小，且如果高位数据较大则地位不需要比较了，高位相同的再比较低位。

## Reference

1. [数据结构与算法之美(11,12,13,14,28), by 王争](https://time.geekbang.org/column/intro/126)
1. [《数据结构高分笔记》](https://book.douban.com/subject/33448923/)
